# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Webpack

Структура проекта:

- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовыми компонентами
- src/models/ — папка с JS моделями
- src/models/base/ — папка с базовыми моделями

Важные файлы:

- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск

Перед установкой и запуском проекта необходимо проверить наличие файла .env с ключем `API_ORIGIN`, который указывает на адрес сервера API:

```
API_ORIGIN=https://example.com
```

Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```

## Сборка

```
npm run build
```

или

```
yarn build
```

## Общая концепция работы приложения

Приложение построено на основе архитектуры, которая сочетает различные паттерны и методы для упрощения работы с данными, отображениями и событиями. Основная цель — организовать код так, чтобы каждый компонент был ответственен за конкретные задачи и мог взаимодействовать с другими через четко определенные интерфейсы. Для этого используются базовые классы, абстракции и связь через события.

Список доступных по умолчанию событий, а также данные, которые передаются в рамках события описаны ниже для конкретного View или Model

Для описания товара используется интерфейс `IProduct`:

```ts
interface IProduct {
	id: string;
	description: string;
	image: string;
	title: string;
	category: string;
	price: number | null;
}
```

Для описания возможных способов оплаты заказа используется тип `TOrderPayment`:

```ts
type TOrderPayment = 'cash' | 'card';
```

Для описания заказа используется интерфейс `IOrder`:

```ts
interface IOrder {
	items: IProduct[];
	payment: TOrderPayment;
	address: string;
	email: string;
	phone: string;
}
```

При оформлении заказа, формируется специальный объект для работы с API типа `TOrderInvoice`:

```ts
type TOrderInvoice = Omit<IOrder, 'items'> & {
	items: string[];
	total: number;
};
```

Для отслеживания текущего этапа заказа используется тип `TOrderStep`:

```ts
type TOrderStep = 'shipment' | 'contacts';
```

## Базовые и связующие блоки

### Базовый класс `API`

Класс API представляет собой интерфейс для работы с внешними данными. Его задача — обеспечивать взаимодействие между приложением и серверной частью, поддерживая обмен запросами и ответами. Этот класс абстрагирует взаимодействие с API, предоставляя удобные методы для отправки запросов и получения данных.

В качестве набора HTTP методов использует тип `TApiPostMethods`:

```ts
type TApiPostMethods = 'POST' | 'PUT' | 'DELETE';
```

### Базовый класс `EventEmitter`

EventEmitter — это класс, который реализует механизм подписки и уведомления, позволяя разным компонентам приложения обмениваться событиями. Это помогает избежать жесткой связи между модулями и поддерживать более гибкую архитектуру, где компоненты могут реагировать на события, не зная напрямую, кто их сгенерировал.

Реализует интерфейс `IEvents`, использует типы `TEmitterEvent`, `TSubscriber`, `TEventName`:

```ts
type TEventName = string | RegExp;

type TSubscriber = Function;

type TEmitterEvent = {
	eventName: string;
	data: unknown;
};

interface IEvents {
	on<T extends object>(event: TEventName, callback: (data: T) => void): void;
	emit<T extends object>(event: string, data?: T): void;
	trigger<T extends object>(
		event: string,
		context?: Partial<T>
	): (data: T) => void;
}
```

### Абстрактный класс `Model`

Класс Model служит для определения структуры данных и базовой логики для работы с ними. Он может содержать методы для валидации, преобразования или сохранения данных. Будучи абстрактным, он задает основу, которую конкретные модели могут расширять для своих нужд (который принимает часть данных дженерика, привязанного к интерфейсу модели, а также инстанс брокера событий, который реализует `IEvents`), а также метод `emitChanges` для сообщения об изменении внутренних данных используя `EventEmitter`

### Абстрактный класс `View`

View отвечает за отображение данных на экране. Абстрактный класс предоставляет базовые методы для работы с DOM-элементами, их обновления и управления интерфейсом. Этот класс помогает разрабатывать единообразные компоненты интерфейса, которые могут легко обновляться при изменении данных, а также метод для рендера `render` привязанного к отображению DOM элемента с определенным набором параметров `args`, также содержит список привязанных к отображению событий и брокер событий для сообщений о внутренних событиях

Конструктор принимает в качестве аргумента специальный тип `TViewConstructionArgs`, содержащий DOM элемент, привязанный к View, брокер и список доступных событий:

```ts
type TViewConstructionArgs<
	Element extends HTMLElement = HTMLElement,
	EventHandlers extends object = object
> = {
	element: Element;
	eventEmitter: IEvents;
	eventHandlers?: EventHandlers;
};
```

Так как View внутри себя может содержать другие View, приложен специальный тип `TViewNested`, который описывает способ хранения дочерних View:

```ts
type TViewNested<RenderArgs extends object = object> = {
	view: IView | HTMLElement;
	renderArgs?: RenderArgs;
};
```

## Модели данных (Model)

### Класс `AppState`

AppState представляет собой глобальное состояние приложения. Этот класс управляет состоянием всего приложения и отвечает за обновление данных в различных частях интерфейса. Он также поддерживает подписку на изменения, что позволяет автоматически обновлять интерфейс при изменении состояния.

Содержит поля интерфейса `IAppState`:

```ts
interface IAppState {
	preview: IProduct;
	basket: Set<IProduct>;
	products: IProduct[];
	order: IOrder;
}
```

Имеет базовый набор методов для управления приложением:

```ts
// Установка этапа оформления заказа
setStep(value: TOrderStep) {}

// Установка поля заказа
setFieldOfOrder(field: keyof IOrder, value: unknown) {}

// Проверка валидности текущего заказа
getOrderIsValid() {}

// Получение ошибок текущего заказа
getOrderErrors() {}

// Получение полей заказа в виде для взаимодействия с API
getOrderInvoice() {}

// Инициализация нового заказа
initOrder() {}

// Сброс всех полей заказа
resetOrder() {}

// Установка товаров каталога
setProductsItems(value: IProduct[]) {}

// Проверка на наличие товара в корзине
getBasketIsContains(id: string) {}

// Добавление товара в корзину
addBasketItem(value: IProduct) {}

// Удаление товара из корзины
removeBasketItem(id: string) {}

// Сброс текущего состояния корзины
resetBasket() {}

// Инициализация корзины
initBasket() {}

// Получение цены позиций в корзине
getBasketPrice() {}

// Установка текущего просматриваемого элемента
setPreview(value: IProduct) {}
```

Доступные события для использования объектом класса `EventEmitter` описаны перечислением `AppStateEvents`:

```ts
enum AppStateEvents {
	// Событие возникающее при изменении списка товаров каталога
	PRODUCTS_UPDATE = 'products:update',
	// Событие возникающее при изменении preview
	PREVIEW_UPDATE = 'preview:update',
	// Событие возникающее при инициализации корзины
	BASKET_INIT = 'basket:init',
	// Событие возникающее при изменении товаров в корзине
	BASKET_UPDATE = 'basket:update',
	// Событие возникающее при сбросе корзины
	BASKET_RESET = 'basket:reset',
	// Событие возникающее при изменении этапа заказа
	ORDER_STEP = 'order:step',
	// Событие возникающее при изменении поля заказа
	ORDER_UPDATE = 'order:update',
	// Событие возникающее при сбросе заказа
	ORDER_RESET = 'order:reset',
}
```

- Событие `PRODUCTS_UPDATE` возникает при вызове метода `setProductsItems` и в качестве данных
  передает объект с полем `data`, поле `data` - объект, содержит поле `items` - текущий список элементов каталога (каждый элемент списка реализует интерфейс `IProduct`)

- Событие `PREVIEW_UPDATE` возникает при вызове метода `setPreview` и в качестве данных
  передает объект с полем `data`, поле `data` - объект, содержит поле `item` - текущий просматриваемый товар (товар реализует интерфейс `IProduct`)

- Событие `BASKET_INIT` возникает при вызове метода `initBasket` и в качестве данных
  передает объект с полем `data`, поле `data` - объект, содержит поле `items` - текущий список элементов корзины (каждый элемент списка реализует интерфейс `IProduct`)

- Событие `BASKET_UPDATE` возникает при вызове методов `addBasketItem` и `removeBasketItem` и в качестве данных
  передает объект с полем `data`, поле `data` - объект, содержит поле `items` - текущий список элементов корзины (каждый элемент списка реализует интерфейс `IProduct`)

- Событие `BASKET_RESET` возникает при вызове метода `resetBasket` и в качестве данных
  передает объект с полем `data`, поле `data` - объект, содержит поле `items` - текущий список элементов корзины (каждый элемент списка реализует интерфейс `IProduct`)

- Событие `ORDER_STEP` возникает при вызове метода `setStep` и в качестве данных
  передает объект с полем `data`, поле `data` - объект, содержит поле `step` - текущий этап оформления заказа (шаг принадлежит типу `TOrderStep`)

- Событие `ORDER_UPDATE` возникает при вызове метода `setFieldOfOrder` и в качестве данных
  передает объект с полем `data`, поле `data` - объект, содержит поле `field` - поле заказа (поле является ключем интерфейса `IOrder`) и поле `value` - значение поля заказа

- Событие `ORDER_RESET` возникает при вызове метода `resetOrder`, не содержит передаваемых данных

## Специальные компоненты

Данный набор компонентов необходим для работы с API и другими службами

### Класс `ShopAPI`

Класс ShopAPI — это специализированная реализация API для работы с данными магазина. Он предоставляет методы для взаимодействия с базой данных продуктов, корзины и заказов, позволяя приложению взаимодействовать с серверной частью, выполняя запросы для получения и отправки данных.

Наследуется от базового класса `API`, при оформлении заказа использует `TOrderInvoice`

## Отображения (View)

### Глобальные компоненты

Данный набор компонентов необходим для работы со страницей

#### Класс `Page`

Page — это базовый класс для всех страниц приложения. Он содержит методы для инициализации и управления компонентами на странице, а также отвечает за рендеринг основных частей интерфейса.


Наследуется от `View`. При рендеринге использует поля типа `TPageRenderArgs`:

```ts
type TPageRenderArgs = {
	isLocked: boolean;
};
```

#### Класс `Header`

Класс Header отвечает за отображение заголовка страницы и может включать в себя меню навигации или другие глобальные элементы управления. Он также управляет событиями, связанными с навигацией или изменением состояния страницы.

Наследуется от `View`. При рендеринге использует поля типа `THeaderRenderArgs`:

```ts
type THeaderRenderArgs = {
	counter: number;
};
```

Доступный список событий описан типом `THeaderEventHandlers`:

```ts
type THeaderEventHandlers = {
	onClick?: (args: { _event: MouseEvent }) => void;
};
```

#### Класс `Modal`

Modal — это компонент, представляющий модальные окна. Он управляет открытием, закрытием и рендерингом модальных окон, а также обеспечивает взаимодействие с пользователем через интерфейс модальных окон.

Наследуется от `View`. При рендеринге использует поля типа `TModalRenderArgs`:

```ts
type TModalRenderArgs<T extends object> = {
	content: TViewNested<T>;
};
```

Имеет базовый набор методов для управления активностью модального окна:

```ts
// Открыть модальное окно
open() {}
// Закрыть модальное окно
close() {}
```

Доступные события для использования объектом класса `EventEmitter` описаны перечислением `ModalEvents`:

```ts
enum ModalEvents {
	// Закрытие модального окна
	CLOSE = 'modal:close',
	// Открытие модального окна
	OPEN = 'modal:open',
}
```

- Событие `CLOSE` возникает при вызове метода `open`, не содержит передаваемых данных

- Событие `OPEN` возникает при вызове метода `close`, не содержит передаваемых данных

#### Класс `Form`

Класс Form используется для работы с формами. Он предоставляет методы для валидации и отправки данных, а также для управления состоянием формы (например, загрузка, ошибки или успешная отправка).

Наследуется от `View`. При рендеринге использует поля типа `TFormRenderArgs`:

```ts
type TFormRenderArgs = {
	isDisabled: boolean;
	errors: string[];
};
```

Доступный список событий описан типом `TFormEventHandlers`:

```ts
type TFormEventHandlers = {
	onSubmit?: (args: { _event: SubmitEvent }) => void;
	onInput?: (args: {
		_event: InputEvent;
		field: string;
		value: unknown;
	}) => void;
};
```

### Компоненты корзины

Данный набор компонентов необходим для работы с пользовательской корзиной

#### Класс `Basket`

Basket — это класс, представляющий корзину покупок. Он управляет добавлением и удалением товаров, а также подсчитывает общую стоимость товаров в корзине. Этот класс также может взаимодействовать с другими частями приложения для обновления состояния корзины в реальном времени.



Наследуется от `View`. При рендеринге использует поля типа `TBasketRenderArgs`:

```ts
type TBasketRenderArgs<T extends object> = {
	items: TViewNested<T>[];
	price: string;
	isDisabled: boolean;
};
```

Доступный список событий описан типом `TBasketEventHandlers`:

```ts
type TBasketEventHandlers = {
	onClick?: (args: { _event: MouseEvent }) => void;
};
```

#### Класс `BasketItem`

BasketItem представляет собой отдельный товар в корзине. Этот класс содержит информацию о товаре, количестве, цене и предоставляет методы для изменения количества товара или удаления его из корзины.

Наследуется от `View`. При рендеринге использует поля типа `TBasketItemRenderArgs`:

```ts
type TBasketItemRenderArgs = {
	index: number;
	title: string;
	price: string;
};
```

Доступный список событий описан типом `TBasketItemEventHandlers`:

```ts
type TBasketItemEventHandlers = {
	onClick?: (args: { _event: MouseEvent }) => void;
};
```

### Компоненты заказа

Данный набор компонентов необходим для работы с пользовательским заказов

#### Класс `OrderShipment`

OrderShipment отвечает за ввод и валидацию данных по доставке товара. Он может включать формы для выбора метода доставки, указания адреса и расчета стоимости доставки.

Наследуется от `Form`. При рендеринге использует поля типа `TOrderShipmentRenderArgs`:

```ts
type TOrderShipmentRenderArgs = {
	payment: string;
	address: string;
} & TFormRenderArgs;
```

Использует список событий типа `TFormEventHandlers`

#### Класс `OrderContacts`

Этот класс управляет сбором и валидацией контактных данных для оформления заказа. Он отвечает за взаимодействие с полями ввода данных и проверку правильности заполнения.

Наследуется от `Form`. При рендеринге использует поля типа `TOrderContactsRenderArgs`:

```ts
type TOrderContactsRenderArgs = {
	email: string;
	phone: string;
} & TFormRenderArgs;
```

Использует список событий типа `TFormEventHandlers`

#### Класс `OrderSuccess`

OrderSuccess отображает информацию об успешном завершении заказа. Он может содержать благодарственное сообщение, информацию о заказе и другие важные данные, подтверждающие успешное оформление.



Наследуется от `View`. При рендеринге использует поля типа `TOrderSuccessRenderArgs`:

```ts
type TOrderSuccessRenderArgs = {
	description: string;
};
```

Доступный список событий описан типом `TOrderSuccessEventHandlers`:

```ts
type TOrderSuccessEventHandlers = {
	onClick?: (args: { _event: MouseEvent }) => void;
};
```

### Компоненты товаров

Данный набор компонентов необходим для работы с отображением товаров магазина

#### Класс `Products`

Products — это компонент, который управляет списком товаров на странице. Он отвечает за рендеринг товаров и их взаимодействие с корзиной, такими как добавление в корзину или просмотр деталей.


Наследуется от `View`. При рендеринге использует поля типа `TProductsRenderArgs`:

```ts
type TProductsRenderArgs<T extends object> = {
	items: TViewNested<T>[];
};
```

#### Класс `Product`

Product представляет собой отдельный товар. Этот класс содержит всю информацию о товаре, включая его название, описание, цену и изображения, а также предоставляет методы для взаимодействия с товаром, например, добавления в корзину.


Наследуется от `View`. При рендеринге по умолчанию использует поля типа `TProductRenderArgs`:

```ts
type TProductRenderArgs = Pick<IProduct, 'image' | 'title' | 'category'> & {
	price: string;
	color: string | null;
};
```

Доступный список событий по умолчанию описан типом `TProductEventHandlers`:

```ts
type TProductEventHandlers = {
	onClick?: (args: { _event: MouseEvent }) => void;
};
```

#### Класс `ProductPreview`

ProductPreview — это класс, который отвечает за отображение предварительного просмотра товара. Он может быть использован для отображения миниатюрного изображения товара или краткого описания, которое открывается при наведении или клике.

Наследуется от `Product`. При рендеринге использует поля типа `TProductPreviewRenderArgs`:

```ts
type TProductPreviewRenderArgs = {
	description: string;
	buttonText: string;
	isDisabled: boolean;
} & TProductRenderArgs;
```

Использует список событий типа `TProductEventHandlers`
